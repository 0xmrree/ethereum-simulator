One misconception I had is that GossipSub is just a regular network application protocol with some state. GossipSub is a network app protocol within a wider protocol to manage what happens across streams. The way it works: you tell GossipSub what topics you are interested in. It then takes peers and opens up N GossipSub streams and sends them SUBSCRIBE messages to let them know what topics you want to participate in. Then from these channels—and others that peers opened with you—you also receive SUBSCRIBE messages back. As SUBSCRIBE messages come in for each topic, you build a list of gossip peers for that topic (these are a subset of the total peers you have GossipSub streams open with). At this point your mesh is empty. Then during the first heartbeat, you build a mesh for each topic by sending GRAFT messages to a subset of gossip peers for that topic. Mesh peers agree to send each other full topic messages when received. The way it works is: as a topic's mesh peers send you topic data via MESSAGE, you forward to your other mesh peers, and also send lightweight IHAVE messages containing just the message hash to your gossip peers not in the mesh. Then at each heartbeat, the mesh is maintained—sending GRAFT to add peers or PRUNE to remove peers as a function of mesh size and peer scores. In addition, during the heartbeat we check if any gossip peer sent us an IHAVE for a message we haven't received; if so, we request the full message with IWANT. This two-pronged approach—having a lightweight gossip peer set and a heavy mesh set per topic—balances decentralization and data availability by not overloading the network with full messages but ensuring we have a backup plan via IWANT so we don't miss data.
