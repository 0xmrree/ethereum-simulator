## ligh client protocol summary

So the goal is a trustless way to do operations (at least read, for write technically) on chain without having to trust a single node for their view of the chain. 
Bootstrap phase - get the first pub keys:
First you get some checkpointRoot which is just a hash of a beacon block header at some checkpoint slot in the past. This root is gotten from social consensus but you already have trust in your wallet provider so the trust profile is not changing much. Then you take this root and poke a beacon node API you know about and request LightClientBootstrap message which will contain the block header, sync committee pub keys, and merkle proof of sync committee within beacon state. Then you prove your sync pub keys exist in the beacon state of your root, then verify the hash of the header equals the checkpoint, thus you trustlessly verified the public keys belonging to the checkpoint you are bootstrapping from. Even if you connected to a bad actor who wants you to believe in a fake chain with his own pub keys, he could not because he would need pre image attack the hash of his fake header (> bitcoins entire POW).
Sync phase - get to the last sync period :
Now with your trusted pub keys that are RANDAO-style chosen by the protocol, you will keep getting the next best sync attested block header 256 epochs downstream. You will move forward each sync period of 256 epochs by processing a LightClientUpdate message. To verify it you first take the attested header which is what the committee signed and verify it against the given aggregate signature - you can do this because you have your trusted public keys starting from bootstrap. The specific attested header is chosen by finding a block in the period with the best sync committee participation and latest finality advancement. Then after you verify, you have a trusted attested header which contains a beacon state root. You take this beacon state root and verify the finalized header via its merkle proof. Now you have both a new trusted finalized header and a new trusted head block. Given you will have the next sync committee in the beacon state of the attested header, you can now repeat this process until you get to the head of the chain forming a chain of proofs all the way from the checkpoint root you started with.
Note that if in a given period no blocks get 2/3 sync attestations, all light clients will break until a new checkpointRoot is given out pased that period.
Gossip phase:
Gossip phase is pretty easy to understand. Within a period you will basically have a current latest LMD GHOST head with sync committee  proof and the latest finalized header, and you will verify these as they come with your pub keys from the committee and the aggregate signatures via subscribing to topics. Then when you approach a sync period boundary you will request the same LightClientUpdate from sync phase, verify it, and update your local sync committee pub keys just like you did before, then repeat your logic for the gossip topics as new blocks come in. You want to maintain both local current LMD GHOST header and the finalized header so wallets and applications can use both depending on use cases. And of course this info is vital because you just take the execution world state root and find an RPC server soyou can verify with the EL's merkle proof. You don't have to trust the RPC, you just need to find one honest one.   (: